C51 COMPILER V9.57.0.0   POE_M                                                             06/17/2018 19:42:40 PAGE 1   


C51 COMPILER V9.57.0.0, COMPILATION OF MODULE POE_M
OBJECT MODULE PLACED IN .\Objects\poe_m.obj
COMPILER INVOKED BY: D:\Keil_v5_957\C51\BIN\C51.EXE src\poe_m.c OPTIMIZE(8,SPEED) BROWSE INCDIR(.\inc) DEBUG OBJECTEXTEN
                    -D PRINT(.\Listings\poe_m.lst) TABS(2) OBJECT(.\Objects\poe_m.obj)

line level    source

   1          #include "i2c.h"
   2          #include "uart.h"
   3          #include "poe_m.h"
   4          #include "tt9980.h"
   5          #include "STC8xxxx.h"
   6          
   7          static uint16_t xdata pwrled_time = 0;  //led flash time
   8          
   9          static uint8_t i2c_salve[MAX_DEVICE] = {TT9980_1_4, TT9980_5_8, TT9980_9_12, TT9980_13_16};
  10          
  11          static uint8_t xdata den_start = 0;     //d enable gradually satrt
  12          
  13          static void set_l(uint8_t dev, uint8_t ch, bit val);
  14          static void g_disable(void);
  15          static void g_enable(void);
  16          static void set_den(uint8_t sta);
  17          
  18          void delay(uint8_t time);
  19          void debug_delay(uint16_t time);
  20          
  21          //========================================================================
  22          // function:    WDG_config
  23          // description: start wdg
  24          // parameter:   void
  25          // return:      void
  26          // version:     V1.0, 2018-1-11
  27          //========================================================================
  28          void WDG_config(void){
  29   1        WDT_CONTR = D_EN_WDT | D_WDT_SCALE_128;
  30   1      }
  31          
  32          //========================================================================
  33          // function:    WDG_freed
  34          // description: wdg clear
  35          // parameter:   void
  36          // return:      void
  37          // version:     V1.0, 2018-1-11
  38          //========================================================================
  39          void WDG_freed(void){
  40   1        WDT_CONTR |= D_CLR_WDT;
  41   1      }
  42          
  43          //========================================================================
  44          // function:    system_init
  45          // description: system init state
  46          // parameter:   void
  47          // return:      void
  48          // version:     V1.0, 2018-5-28
  49          //========================================================================
  50          void system_init(void){
  51   1        uint8_t xdata dev=0, ch=0, state = 0;
  52   1        uint8_t xdata ret = 0, trys = 3;
  53   1        
  54   1        for(dev=0; dev<MAX_DEVICE; dev++)
C51 COMPILER V9.57.0.0   POE_M                                                             06/17/2018 19:42:40 PAGE 2   

  55   1          for(ch=0; ch<MAX_CH; ch++)
  56   1            set_l(dev, ch, L_ON);         //led on : all 
  57   1        
  58   1        PWR_LED = PWR_LED_ON;
  59   1        debug_delay(0x4FFF);
  60   1        for(dev=0; dev<MAX_DEVICE; dev++)
  61   1          for(ch=0; ch<MAX_CH; ch++)
  62   1            set_l(dev, ch, L_OFF);          //led off : all 
  63   1        
  64   1        PWR_LED = PWR_LED_OFF;
  65   1        pwrled_time = PWR_LED_STOP;     //pwrled off
  66   1        
  67   1        set_den(0xFF);
  68   1        
  69   1        state = 0x01;
  70   1        for(dev=0; dev<MAX_DEVICE; dev++){  //set 2th class
  71   2          for(ch=0; ch<MAX_CH; ch++){
  72   3            trys = 3;
  73   3            do{
  74   4              ret = i2c_write(i2c_salve[dev], GPDM(ch), &state, 1);
  75   4            }while(ret && trys--);
  76   3          }
  77   2        }
  78   1        
  79   1        state = 0x00;
  80   1        for(dev=0; dev<MAX_DEVICE; dev++){  //set pwr on
  81   2          trys = 3;
  82   2          do{
  83   3            ret = i2c_write(i2c_salve[dev], PWR_ON, &state, 1);
  84   3          }while(ret && trys--);
  85   2        }
  86   1        
  87   1        state = 0xFF;
  88   1        for(dev=0; dev<MAX_DEVICE; dev++){  //set work mode
  89   2          trys = 3;
  90   2          do{
  91   3            ret = i2c_write(i2c_salve[dev], WORK_MODE, &state, 1);
  92   3          }while(ret && trys--);
  93   2        }
  94   1      }
  95          
  96          //========================================================================
  97          // function:    timeEv_open_den
  98          // description: d enable gradually
  99          // parameter:   void
 100          // return:      void
 101          // version:     V1.0, 2018-5-28
 102          //========================================================================
 103          void timeEv_open_den(uint8_t tick){
 104   1        static uint16_t xdata den_tick = 0;
 105   1        if(den_start >= ALL_CH)
 106   1          return;
 107   1        den_tick += tick;
 108   1        if(den_tick > T_EN_D){
 109   2          g_enable();
 110   2          den_start++;
 111   2        }
 112   1      }
 113          
 114          //========================================================================
 115          // function:    timeEv_pwrled
 116          // description: pwr led flash
C51 COMPILER V9.57.0.0   POE_M                                                             06/17/2018 19:42:40 PAGE 3   

 117          // parameter:   tick
 118          // return:      void
 119          // version:     V2.0, 2018-4-25
 120          //========================================================================
 121          void timeEv_pwrled(uint8_t tick){
 122   1        static uint16_t xdata pwrled_tick = 0;
 123   1        pwrled_tick += tick;
 124   1        if(PWR_LED_STOP == pwrled_time)
 125   1          return;
 126   1        if(pwrled_tick > pwrled_time){
 127   2          pwrled_tick = 0;
 128   2          PWR_LED = !PWR_LED;
 129   2        }
 130   1      }
 131          
 132          //========================================================================
 133          // function:    timeEv_getGsta
 134          // description: uart1 interrupt_ service handle
 135          // parameter:   tick
 136          // return:      void
 137          // version:     V2.0, 2018-5-25
 138          //========================================================================
 139          void timeEv_getGsta(uint8_t tick){
 140   1        static uint16_t xdata getg_tick = 0;
 141   1        static uint8_t xdata g_slave = 0;
 142   1        uint8_t state = 0, ch = 0, ret = 0;
 143   1        getg_tick += tick;
 144   1        if(getg_tick > T_GET_G){
 145   2          getg_tick = 0;
 146   2          ret = i2c_read(i2c_salve[g_slave], PWR_STATE, &state, 1);
 147   2          if(ret)
 148   2            state = G_OFF<<0 | G_OFF<<1 | G_OFF<<2 | G_OFF<<3; //if i2c_err, then led_off
 149   2          for(ch=0; ch<MAX_CH; ch++){
 150   3            if(((state>>ch)&0x01) == G_ON)
 151   3              set_l(g_slave, ch, L_ON);
 152   3            else
 153   3              set_l(g_slave, ch, L_OFF);
 154   3          }
 155   2          if(++g_slave >= MAX_DEVICE)
 156   2            g_slave = 0;
 157   2        }
 158   1      }
 159          
 160          //========================================================================
 161          // function:    timeEv_getIU
 162          // description: get slave current and voltage
 163          // parameter:   tick
 164          // return:      void
 165          // version:     V2.0, 2018-5-25
 166          //========================================================================
 167          void timeEv_getIU(uint8_t tick){
 168   1        static uint16_t xdata getiu_tick = 0;
 169   1        uint8_t trys = 0, state = 0, ret = 0;
 170   1        getiu_tick += tick;
 171   1        if(getiu_tick > T_GET_IU){
 172   2          uint8_t dev = 0, ch = 0;
 173   2          uint32_t sum_iu = 0;
 174   2          getiu_tick = 0;
 175   2          for(dev=0; dev<MAX_DEVICE; dev++){
 176   3            uint8_t ret = 0;
 177   3            uint8_t pbuf[U4_H-U1_L+1] = {0};
 178   3            ret = i2c_read(i2c_salve[dev], I1_L, pbuf, U4_H-I1_L+1);
C51 COMPILER V9.57.0.0   POE_M                                                             06/17/2018 19:42:40 PAGE 4   

 179   3            if(!ret){
 180   4              for(ch=0; ch<MAX_CH; ch++)
 181   4                sum_iu += ((uint16_t)pbuf[ch<<2] | ((uint16_t)pbuf[(ch<<2)+1]<<8));
 182   4            }
 183   3          }
 184   2          if(sum_iu > IU_MAX){          // >100%
 185   3      //      set_den(0x00);                  // d_off : all
 186   3            g_disable();                // g_off + d_off : one
 187   3            state = 0xAA;
 188   3            for(dev=0; dev<MAX_DEVICE; dev++){  //set work mode
 189   4              trys = 3;
 190   4              do{
 191   5                ret = i2c_write(i2c_salve[dev], WORK_MODE, &state, 1);
 192   5              }while(ret && trys--);
 193   4            }
 194   3            den_start = ALL_CH;
 195   3            pwrled_time = PWR_LED_MAX;
 196   3          }
 197   2          else if(sum_iu > IU_MID){     // >95%
 198   3            //beta
 199   3            state = 0x00;
 200   3            for(dev=0; dev<MAX_DEVICE; dev++){
 201   4              trys = 3;
 202   4              do{
 203   5                ret = i2c_write(i2c_salve[dev], PWR_ON, &state, 1);
 204   5              }while(ret && trys--);
 205   4            }
 206   3      //      set_den(0x00);                  // d_off : all
 207   3            //beta
 208   3            state = 0xAA;
 209   3            for(dev=0; dev<MAX_DEVICE; dev++){  //set work mode
 210   4              trys = 3;
 211   4              do{
 212   5                ret = i2c_write(i2c_salve[dev], WORK_MODE, &state, 1);
 213   5              }while(ret && trys--);
 214   4            }
 215   3            den_start = ALL_CH;
 216   3            pwrled_time = PWR_LED_FAST;
 217   3          }
 218   2          else if(sum_iu > IU_NOR){     // >75%
 219   3            //beta
 220   3            state = 0x0F;
 221   3            for(dev=0; dev<MAX_DEVICE; dev++){
 222   4              trys = 3;
 223   4              do{
 224   5                ret = i2c_write(i2c_salve[dev], PWR_ON, &state, 1);
 225   5              }while(ret && trys--);
 226   4            }
 227   3      //      set_den(0xFF);
 228   3            //beta
 229   3            state = 0xFF;
 230   3            for(dev=0; dev<MAX_DEVICE; dev++){  //set work mode
 231   4              trys = 3;
 232   4              do{
 233   5                ret = i2c_write(i2c_salve[dev], WORK_MODE, &state, 1);
 234   5              }while(ret && trys--);
 235   4            }
 236   3            den_start = ALL_CH;
 237   3            pwrled_time = PWR_LED_SLOW;
 238   3          }
 239   2          else{                         // <=75%
 240   3            //beta
C51 COMPILER V9.57.0.0   POE_M                                                             06/17/2018 19:42:40 PAGE 5   

 241   3            state = 0x0F;
 242   3            for(dev=0; dev<MAX_DEVICE; dev++){
 243   4              trys = 3;
 244   4              do{
 245   5                ret = i2c_write(i2c_salve[dev], PWR_ON, &state, 1);
 246   5              }while(ret && trys--);
 247   4            }
 248   3      //      set_den(0xFF);
 249   3            //beta
 250   3            state = 0xFF;
 251   3            for(dev=0; dev<MAX_DEVICE; dev++){  //set work mode
 252   4              trys = 3;
 253   4              do{
 254   5                ret = i2c_write(i2c_salve[dev], WORK_MODE, &state, 1);
 255   5              }while(ret && trys--);
 256   4            }
 257   3            pwrled_time = PWR_LED_STOP;
 258   3            PWR_LED = PWR_LED_OFF;
 259   3            if(den_start<ALL_CH) return;
 260   3      //      g_enable();                 // g_on + d_on : one
 261   3          }
 262   2        }
 263   1      }
 264          
 265          //========================================================================
 266          // function:    g_disable
 267          // description: close gate witch is ON and lower previlige
 268          // parameter:   void
 269          // return:      closed flag
 270          // version:     V1.0, 2018-5-28
 271          //========================================================================
 272          static void g_disable(void){
 273   1        char xdata ret = 0, dev = 0, ch = 0;
 274   1        uint8_t g_state = 0, d_state = 0, close_state = 0;
 275   1        for(dev=MAX_DEVICE-1; dev>=0; dev--){
 276   2          uint8_t ret = 0, trys = 3;
 277   2          do{
 278   3            ret = i2c_read(i2c_salve[dev], PWR_STATE, &g_state, 1);
 279   3          }while(ret && trys--);
 280   2          if(ret) continue;
 281   2          for(ch=MAX_CH-1; ch>=0; ch--){
 282   3            if((g_state>>ch)&0x01 == G_ON){
 283   4              //test
 284   4              TX1_write2buff('d');
 285   4              TX1_write2buff('1'+dev);
 286   4              TX1_write2buff('1'+ch);
 287   4              TX1_write2buff('\n');
 288   4              //test
 289   4              close_state |= (0x10<<ch);
 290   4              trys = 3;
 291   4              do{
 292   5                ret = i2c_write(i2c_salve[dev], PWR_ON, &close_state, 1);
 293   5              }while(ret && trys--);
 294   4              return;
 295   4            }
 296   3          }
 297   2        }
 298   1      }
 299          
 300          //========================================================================
 301          // function:    g_enable
 302          // description: open gate witch is OFF and higher previlige
C51 COMPILER V9.57.0.0   POE_M                                                             06/17/2018 19:42:40 PAGE 6   

 303          // parameter:   void
 304          // return:      closed flag
 305          // version:     V1.0, 2018-5-28
 306          //========================================================================
 307          static void g_enable(void){
 308   1        char xdata ret = 0, dev = 0, ch = 0;
 309   1        uint8_t d_state = 0, g_state = 0, pwr_state = 0;
 310   1        for(dev=0; dev<MAX_DEVICE; dev++){
 311   2          uint8_t ret = 0, trys = 3;
 312   2          do{
 313   3            ret = i2c_read(i2c_salve[dev], PWR_STATE, &pwr_state, 1);
 314   3          }while(ret && trys--);
 315   2          if(ret) continue;
 316   2          for(ch=0; ch<MAX_CH; ch++){
 317   3            if(((pwr_state>>ch)&0x01) == 0){
 318   4              //test
 319   4              TX1_write2buff('e');
 320   4              TX1_write2buff('1'+dev);
 321   4              TX1_write2buff('1'+ch);
 322   4              TX1_write2buff('\n');
 323   4              //test
 324   4              g_state = 0x0F;
 325   4              trys = 3;
 326   4              do{
 327   5                ret = i2c_write(i2c_salve[dev], PWR_ON, &g_state, 1);
 328   5              }while(ret && trys--);
 329   4              return;
 330   4            }
 331   3          }
 332   2        }
 333   1      }
 334          
 335          //========================================================================
 336          // function:    set_den
 337          // description: set d enable / disable
 338          // parameter:   void
 339          // return:      void
 340          // version:     V1.0, 2018-5-28
 341          //========================================================================
 342          static void set_den(uint8_t sta){
 343   1        uint8_t xdata dev = 0, ret = 0, trys = 3;
 344   1      //  static uint8_t xdata den_flag[MAX_DEVICE] = {0};    //d flag
 345   1        for(dev=0; dev<MAX_DEVICE; dev++){
 346   2      //    if(den_flag[dev] == sta) continue;
 347   2      //    den_flag[dev] = sta;
 348   2          trys = 3;
 349   2          do{
 350   3            ret = i2c_write(i2c_salve[dev], DET_EN, &sta, 1);
 351   3          }while(ret && trys--);
 352   2        }
 353   1      }
 354          
 355          //========================================================================
 356          // function:    set_l
 357          // description: set led on/off
 358          // parameter:   device, channel, state
 359          // return:      void
 360          // version:     V2.0, 2018-5-25
 361          //========================================================================
 362          static void set_l(uint8_t dev, uint8_t ch, bit val){
 363   1        uint8_t l = 0xff;
 364   1        if(dev<MAX_DEVICE && ch<MAX_CH)
C51 COMPILER V9.57.0.0   POE_M                                                             06/17/2018 19:42:40 PAGE 7   

 365   1          l = dev*MAX_CH+ch;
 366   1        l += 8;
 367   1        switch(l){
 368   2          case 0:  L1 = val; break;
 369   2          case 1:  L2 = val; break;
 370   2          case 2:  L3 = val; break;
 371   2          case 3:  L4 = val; break;
 372   2          case 4:  L5 = val; break;
 373   2          case 5:  L6 = val; break;
 374   2          case 6:  L7 = val; break;
 375   2          case 7:  L8 = val; break;
 376   2          case 8:  L9 = val; break;
 377   2          case 9:  L10 = val; break;
 378   2          case 10: L11 = val; break;
 379   2          case 11: L12 = val; break;
 380   2          case 12: L13 = val; break;
 381   2          case 13: L14 = val; break;
 382   2          case 14: L15 = val; break;
 383   2          case 15: L16 = val; break;
 384   2          case 16: L17 = val; break;
 385   2          case 17: L18 = val; break;
 386   2          case 18: L19 = val; break;
 387   2          case 19: L20 = val; break;
 388   2          case 20: L21 = val; break;
 389   2          case 21: L22 = val; break;
 390   2          case 22: L23 = val; break;
 391   2          case 23: L24 = val; break;
 392   2          default:break;
 393   2        }
 394   1      }
 395          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1968    ----
   CONSTANT SIZE    =     14    ----
   XDATA SIZE       =     12      14
   PDATA SIZE       =   ----    ----
   DATA SIZE        =      4      37
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----       1
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
