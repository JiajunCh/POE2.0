C51 COMPILER V9.57.0.0   POE_M                                                             06/18/2018 14:10:40 PAGE 1   


C51 COMPILER V9.57.0.0, COMPILATION OF MODULE POE_M
OBJECT MODULE PLACED IN .\Objects\poe_m.obj
COMPILER INVOKED BY: D:\keil4_c51\C51\BIN\C51.EXE src\poe_m.c OPTIMIZE(8,SPEED) BROWSE INCDIR(.\inc) DEBUG OBJECTEXTEND 
                    -PRINT(.\Listings\poe_m.lst) TABS(2) OBJECT(.\Objects\poe_m.obj)

line level    source

   1          #include "i2c.h"
   2          #include "uart.h"
   3          #include "poe_m.h"
   4          #include "tt9980.h"
   5          #include "STC8xxxx.h"
   6          
   7          static uint16_t xdata pwrled_time = 0;  //led flash time
   8          
   9          uint8_t i2c_salve[MAX_DEVICE] = {TT9980_1_4, TT9980_5_8, TT9980_9_12, TT9980_13_16};
  10          
  11          static void set_led(uint8_t dev, uint8_t ch, bit val);
  12          static void g_disable(void);
  13          static void g_enable(void);
  14          static void set_allled(bit val);
  15          
  16          extern void delay(uint8_t time);
  17          extern void debug_delay(uint8_t time);
  18          
  19          //========================================================================
  20          // function:    WDG_config
  21          // description: start wdg
  22          // parameter:   void
  23          // return:      void
  24          // version:     V1.0, 2018-1-11
  25          //========================================================================
  26          void WDG_config(void){
  27   1        WDT_CONTR = D_EN_WDT | D_WDT_SCALE_128;
  28   1      }
  29          
  30          //========================================================================
  31          // function:    WDG_freed
  32          // description: wdg clear
  33          // parameter:   void
  34          // return:      void
  35          // version:     V1.0, 2018-1-11
  36          //========================================================================
  37          void WDG_freed(void){
  38   1        WDT_CONTR |= D_CLR_WDT;
  39   1      }
  40          
  41          //========================================================================
  42          // function:    system_init
  43          // description: system init state
  44          // parameter:   void
  45          // return:      void
  46          // version:     V1.0, 2018-5-28
  47          //========================================================================
  48          void system_init(void){
  49   1        uint8_t xdata ch=0;
  50   1        
  51   1        set_allled(L_ON); //led on : all 
  52   1        PWR_LED = PWR_LED_ON; //pwrled on
  53   1        debug_delay(0x4FFF);
  54   1        set_allled(L_OFF);  //led off : all 
C51 COMPILER V9.57.0.0   POE_M                                                             06/18/2018 14:10:40 PAGE 2   

  55   1        PWR_LED = PWR_LED_OFF;  //pwrled off
  56   1        pwrled_time = PWR_LED_STOP;     //pwrled off
  57   1        
  58   1        tt_write(DET_EN, 0xFF); //open det/class
  59   1        tt_write(PWR_ON, 0x00); //set pwr on
  60   1        tt_write(WORK_MODE, MODE_AUTO); //set work mode 
  61   1        for(ch=0; ch<MAX_CH; ch++)
  62   1          tt_write(GPDM(ch), 0x01); //set class level_2
  63   1      }
  64          
  65          //========================================================================
  66          // function:    timeEv_pwrled
  67          // description: pwr led flash
  68          // parameter:   tick
  69          // return:      void
  70          // version:     V2.0, 2018-4-25
  71          //========================================================================
  72          void timeEv_pwrled(uint8_t tick){
  73   1        static uint16_t xdata pwrled_tick = 0;
  74   1        pwrled_tick += tick;
  75   1        if(PWR_LED_STOP == pwrled_time)
  76   1          return;
  77   1        if(pwrled_tick > pwrled_time){
  78   2          pwrled_tick = 0;
  79   2          PWR_LED = !PWR_LED;
  80   2        }
  81   1      }
  82          
  83          //========================================================================
  84          // function:    timeEv_getGsta
  85          // description: uart1 interrupt_ service handle
  86          // parameter:   tick
  87          // return:      void
  88          // version:     V2.0, 2018-5-25
  89          //========================================================================
  90          void timeEv_getGsta(uint8_t tick){
  91   1        static uint16_t xdata getg_tick = 0;
  92   1        static uint8_t xdata g_slave = 0;
  93   1        uint8_t state = 0, ch = 0, ret = 0;
  94   1        getg_tick += tick;
  95   1        if(getg_tick > T_GET_G){
  96   2          getg_tick = 0;
  97   2          ret = i2c_read(i2c_salve[g_slave], PWR_STATE, &state, 1);
  98   2          if(ret)
  99   2            state = G_OFF ? 0x0F : 0x00;  //if i2c_err, then led_off
 100   2          for(ch=0; ch<MAX_CH; ch++){
 101   3            if(((state>>ch)&0x01) == G_ON)
 102   3              set_led(g_slave, ch, L_ON);
 103   3            else
 104   3              set_led(g_slave, ch, L_OFF);
 105   3          }
 106   2          if(++g_slave >= MAX_DEVICE)
 107   2            g_slave = 0;
 108   2        }
 109   1      }
 110          
 111          //========================================================================
 112          // function:    timeEv_getIU
 113          // description: get slave current and voltage
 114          // parameter:   tick
 115          // return:      void
 116          // version:     V2.0, 2018-5-25
C51 COMPILER V9.57.0.0   POE_M                                                             06/18/2018 14:10:40 PAGE 3   

 117          //========================================================================
 118          void timeEv_getIU(uint8_t tick){
 119   1        static uint16_t xdata getiu_tick = 0;
 120   1        uint8_t trys = 0, state = 0, ret = 0;
 121   1        getiu_tick += tick;
 122   1        if(getiu_tick > T_GET_IU){
 123   2          uint8_t dev = 0, ch = 0;
 124   2          uint32_t sum_iu = 0;
 125   2          getiu_tick = 0;
 126   2          for(dev=0; dev<MAX_DEVICE; dev++){
 127   3            uint8_t ret = 0;
 128   3            uint8_t pbuf[U4_H-U1_L+1] = {0};
 129   3            ret = i2c_read(i2c_salve[dev], I1_L, pbuf, U4_H-I1_L+1);
 130   3            if(!ret){
 131   4              for(ch=0; ch<MAX_CH; ch++)
 132   4                sum_iu += ((uint16_t)pbuf[ch<<2] | ((uint16_t)pbuf[(ch<<2)+1]<<8));
 133   4            }
 134   3          }
 135   2          if(sum_iu > IU_MAX){          // >100%
 136   3      //      tt_write(DET_EN, 0x00);                 // d_off : all
 137   3            g_disable();                // g_off + d_off : one
 138   3            tt_write(WORK_MODE, MODE_HFAUTO); //set work mode 
 139   3            pwrled_time = PWR_LED_MAX;
 140   3          }
 141   2          else if(sum_iu > IU_MID){     // >95%
 142   3            //beta
 143   3            tt_write(PWR_ON, 0x00); //set pwr on/off
 144   3      //      tt_write(DET_EN, 0x00);                 // d_off : all
 145   3            //beta
 146   3            tt_write(WORK_MODE, MODE_HFAUTO); //set work mode 
 147   3            pwrled_time = PWR_LED_FAST;
 148   3          }
 149   2          else if(sum_iu > IU_NOR){     // >75%
 150   3            //beta
 151   3            state = 0x0F;
 152   3            for(dev=0; dev<MAX_DEVICE; dev++){
 153   4              trys = 3;
 154   4              do{
 155   5                ret = i2c_write(i2c_salve[dev], PWR_ON, &state, 1);
 156   5              }while(ret && trys--);
 157   4            }
 158   3      //      tt_write(DET_EN, 0xFF);
 159   3            //beta
 160   3            tt_write(WORK_MODE, MODE_AUTO); //set work mode 
 161   3            pwrled_time = PWR_LED_SLOW;
 162   3          }
 163   2          else{                         // <=75%
 164   3            //beta
 165   3            state = 0x0F;
 166   3            for(dev=0; dev<MAX_DEVICE; dev++){
 167   4              trys = 3;
 168   4              do{
 169   5                ret = i2c_write(i2c_salve[dev], PWR_ON, &state, 1);
 170   5              }while(ret && trys--);
 171   4            }
 172   3      //      tt_write(DET_EN, 0xFF);
 173   3            //beta
 174   3            tt_write(WORK_MODE, MODE_AUTO); //set work mode 
 175   3            pwrled_time = PWR_LED_STOP;
 176   3            PWR_LED = PWR_LED_OFF;
 177   3      //      g_enable();                 // g_on + d_on : one
 178   3          }
C51 COMPILER V9.57.0.0   POE_M                                                             06/18/2018 14:10:40 PAGE 4   

 179   2        }
 180   1      }
 181          
 182          //========================================================================
 183          // function:    g_disable
 184          // description: close gate witch is ON and lower previlige
 185          // parameter:   void
 186          // return:      closed flag
 187          // version:     V1.0, 2018-5-28
 188          //========================================================================
 189          static void g_disable(void){
 190   1        char xdata ret = 0, dev = 0, ch = 0;
 191   1        uint8_t g_state = 0, pwr_state = 0;
 192   1        for(dev=MAX_DEVICE-1; dev>=0; dev--){
 193   2          ret = tt_read(dev, PWR_STATE, &pwr_state);  //read pwr state
 194   2          if(ret) continue;
 195   2          for(ch=MAX_CH-1; ch>=0; ch--){
 196   3            if((pwr_state>>ch)&0x01 == G_ON){   //get pwr_on channal
 197   4              g_state |= (0x10<<ch);
 198   4              tt_write(PWR_ON, g_state);  //set pwr on/off
 199   4              return;
 200   4            }
 201   3          }
 202   2        }
 203   1      }
 204          
 205          //========================================================================
 206          // function:    g_enable
 207          // description: open gate witch is OFF and higher previlige
 208          // parameter:   void
 209          // return:      closed flag
 210          // version:     V1.0, 2018-5-28
 211          //========================================================================
 212          static void g_enable(void){
 213   1        char xdata ret = 0, dev = 0, ch = 0;
 214   1        uint8_t g_state = 0, pwr_state = 0;
 215   1        for(dev=0; dev<MAX_DEVICE; dev++){
 216   2          ret = tt_read(dev, PWR_STATE, &pwr_state);  //read pwr state
 217   2          if(ret) continue;
 218   2          for(ch=0; ch<MAX_CH; ch++){
 219   3            if(((pwr_state>>ch)&0x01) == 0){
 220   4              g_state |= (0x01<<ch);
 221   4              tt_write(PWR_ON, g_state);  //set pwr on/off
 222   4              return;
 223   4            }
 224   3          }
 225   2        }
 226   1      }
 227          
 228          //========================================================================
 229          // function:    set_led
 230          // description: set led on/off
 231          // parameter:   device, channel, state
 232          // return:      void
 233          // version:     V2.0, 2018-6-18
 234          //========================================================================
 235          static void set_led(uint8_t dev, uint8_t ch, bit val){
 236   1        uint8_t l = 0xff;
 237   1        if(dev<6 && ch<MAX_CH)
 238   1          l = dev*MAX_CH+ch;
 239   1        l += 8;
 240   1        switch(l){
C51 COMPILER V9.57.0.0   POE_M                                                             06/18/2018 14:10:40 PAGE 5   

 241   2          case 0:  L1 = val; break;
 242   2          case 1:  L2 = val; break;
 243   2          case 2:  L3 = val; break;
 244   2          case 3:  L4 = val; break;
 245   2          case 4:  L5 = val; break;
 246   2          case 5:  L6 = val; break;
 247   2          case 6:  L7 = val; break;
 248   2          case 7:  L8 = val; break;
 249   2          case 8:  L9 = val; break;
 250   2          case 9:  L10 = val; break;
 251   2          case 10: L11 = val; break;
 252   2          case 11: L12 = val; break;
 253   2          case 12: L13 = val; break;
 254   2          case 13: L14 = val; break;
 255   2          case 14: L15 = val; break;
 256   2          case 15: L16 = val; break;
 257   2          case 16: L17 = val; break;
 258   2          case 17: L18 = val; break;
 259   2          case 18: L19 = val; break;
 260   2          case 19: L20 = val; break;
 261   2          case 20: L21 = val; break;
 262   2          case 21: L22 = val; break;
 263   2          case 22: L23 = val; break;
 264   2          case 23: L24 = val; break;
 265   2          default:break;
 266   2        }
 267   1      }
 268          
 269          //========================================================================
 270          // function:    set_lalled
 271          // description: set led on/off
 272          // parameter:   state
 273          // return:      void
 274          // version:     V2.0, 2018-6-18
 275          //========================================================================
 276          static void set_allled(bit val){
 277   1        uint8_t dev, ch;
 278   1        for(dev=0; dev<MAX_DEVICE; dev++)
 279   1          for(ch=0; ch<MAX_CH; ch++)
 280   1            set_led(dev, ch, val);          //set led all 
 281   1      }
 282          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1175    ----
   CONSTANT SIZE    =     14    ----
   XDATA SIZE       =      9       7
   PDATA SIZE       =   ----    ----
   DATA SIZE        =      4      30
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----       2
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
