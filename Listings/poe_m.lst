C51 COMPILER V9.57.0.0   POE_M                                                             06/23/2018 13:54:08 PAGE 1   


C51 COMPILER V9.57.0.0, COMPILATION OF MODULE POE_M
OBJECT MODULE PLACED IN .\Objects\poe_m.obj
COMPILER INVOKED BY: D:\Keil_v5_957\C51\BIN\C51.EXE src\poe_m.c OPTIMIZE(8,SPEED) BROWSE INCDIR(.\inc) DEBUG OBJECTEXTEN
                    -D PRINT(.\Listings\poe_m.lst) TABS(2) OBJECT(.\Objects\poe_m.obj)

line level    source

   1          #include "i2c.h"
   2          #include "uart.h"
   3          #include "poe_m.h"
   4          #include "tt9980.h"
   5          #include "STC8xxxx.h"
   6          
   7          static uint16_t xdata pwrled_time = 0;  //led flash time
   8          
   9          uint8_t i2c_salve[MAX_DEVICE] = {TT9980_1_4, TT9980_5_8, TT9980_9_12, TT9980_13_16};
  10          
  11          static void lowprio_off(void);
  12          static void highprio_on(void);
  13          static void set_led(uint8_t dev, uint8_t ch, bit val);
  14          static void set_allled(bit val);
  15          
  16          //========================================================================
  17          // function:    any delay function
  18          // description: delay time in while
  19          // parameter:   tick
  20          // return:      void
  21          // version:     V2.0, 2018-6-18
  22          //========================================================================
  23          void delay(uint8_t time){
  24   1        for(;time>0;time--);
  25   1      }
  26          void debug_delay(uint16_t time){
  27   1        for(;time>0;time--)
  28   1          delay(0xFF);
  29   1      }
  30          
  31          //========================================================================
  32          // function:    WDG_config
  33          // description: start wdg
  34          // parameter:   void
  35          // return:      void
  36          // version:     V1.0, 2018-1-11
  37          //========================================================================
  38          void WDG_config(void){
  39   1        WDT_CONTR = D_EN_WDT | D_WDT_SCALE_128;
  40   1      }
  41          
  42          //========================================================================
  43          // function:    WDG_freed
  44          // description: wdg clear
  45          // parameter:   void
  46          // return:      void
  47          // version:     V1.0, 2018-1-11
  48          //========================================================================
  49          void WDG_freed(void){
  50   1        WDT_CONTR |= D_CLR_WDT;
  51   1      }
  52          
  53          //========================================================================
  54          // function:    system_init
C51 COMPILER V9.57.0.0   POE_M                                                             06/23/2018 13:54:08 PAGE 2   

  55          // description: system init state
  56          // parameter:   void
  57          // return:      void
  58          // version:     V2.0, 2018-6-18
  59          //========================================================================
  60          void system_init(void){
  61   1        uint8_t xdata ch=0;
  62   1        
  63   1        set_allled(L_ON); //led on : all 
  64   1        PWR_LED = PWR_LED_ON; //pwrled on
  65   1        debug_delay(0x2FFF);
  66   1        set_allled(L_OFF);  //led off : all 
  67   1        PWR_LED = PWR_LED_OFF;  //pwrled off
  68   1        pwrled_time = PWR_LED_STOP;     //pwrled off
  69   1        
  70   1        ttall_write(WORK_MODE, MODE_HFAUTO);  //set work mode
  71   1        ttall_write(DET_EN, 0xFF);  //open det/class
  72   1        ttall_write(PWR_ON, 0x0F);  //power on
  73   1        for(ch=0; ch<MAX_CH; ch++)
  74   1          ttall_write(GPDM(ch), 0x01);  //set class level_2
  75   1        
  76   1        PrintString1(PRJ_NAME); //test
  77   1      }
  78          
  79          //========================================================================
  80          // function:    timeEv_pwrled
  81          // description: pwr led flash
  82          // parameter:   tick
  83          // return:      void
  84          // version:     V2.0, 2018-6-18
  85          //========================================================================
  86          void timeEv_pwrled(uint8_t tick){
  87   1        static uint16_t xdata pwrled_tick = 0;
  88   1        if(PWR_LED_STOP == pwrled_time)
  89   1          return;
  90   1        pwrled_tick += tick;
  91   1        if(pwrled_tick > pwrled_time){
  92   2          pwrled_tick = 0;
  93   2          PWR_LED = !PWR_LED;
  94   2        }
  95   1      }
  96          
  97          //========================================================================
  98          // function:    timeEv_getGsta
  99          // description: uart1 interrupt_ service handle
 100          // parameter:   tick
 101          // return:      void
 102          // version:     V2.0, 2018-6-18
 103          //========================================================================
 104          void timeEv_getGsta(uint8_t tick){
 105   1        static uint16_t xdata getg_tick = 0;
 106   1        static uint8_t dev = 0;
 107   1        uint8_t state = 0, ch = 0, ret = 0;
 108   1        getg_tick += tick;
 109   1        if(getg_tick > T_GET_G){
 110   2          getg_tick = 0;
 111   2      //    TX1_write2buff('g');  //test
 112   2          ret = tt_read(dev, PWR_STATE, &state);
 113   2          if(ret){
 114   3      //      TX1_write2buff('-');  //test
 115   3            state = (G_OFF ? 0xFF : 0x00);  //if i2c_err, then led_off
 116   3          }
C51 COMPILER V9.57.0.0   POE_M                                                             06/23/2018 13:54:08 PAGE 3   

 117   2      //    else
 118   2      //      TX1_write2buff('|');  //test
 119   2      //    TX1_write2buff('0'+(state&0x0F)); //test
 120   2          for(ch=0; ch<MAX_CH; ch++){
 121   3            if(((state>>ch)&0x01) == G_ON)
 122   3              set_led(dev, ch, L_ON);
 123   3            else
 124   3              set_led(dev, ch, L_OFF);
 125   3          }
 126   2          if((++dev) >= MAX_DEVICE)
 127   2            dev = 0;
 128   2      //    TX1_write2buff('\n'); //test
 129   2        }
 130   1      }
 131          
 132          //========================================================================
 133          // function:    timeEv_getIU
 134          // description: get slave current and voltage
 135          // parameter:   tick
 136          // return:      void
 137          // version:     V2.0, 2018-6-18
 138          //========================================================================
 139          void timeEv_getIU(uint8_t tick){
 140   1        static uint16_t xdata getiu_tick = 0;
 141   1        uint8_t xdata ret = 0;
 142   1        getiu_tick += tick;
 143   1        if(getiu_tick > T_GET_IU){
 144   2          uint8_t dev = 0, ch = 0;
 145   2          uint32_t sum_iu = 0;
 146   2          getiu_tick = 0;
 147   2      //    TX1_write2buff('i');//test
 148   2          for(dev=0; dev<MAX_DEVICE; dev++){      //calculate sum of i*u
 149   3            uint8_t pbuf[U4_H-U1_L+1] = {0};
 150   3            ret = i2c_read(i2c_salve[dev], I1_L, pbuf, U4_H-I1_L+1);
 151   3            if(!ret){
 152   4      //        TX1_write2buff('|');//test
 153   4              for(ch=0; ch<MAX_CH; ch++){
 154   5                sum_iu += (uint16_t)pbuf[ch<<2] | ((uint16_t)pbuf[(ch<<2)+1]<<8);
 155   5              }
 156   4            }
 157   3      //      else  //test
 158   3      //        TX1_write2buff('-');//test
 159   3          }
 160   2      #if (DEBUG)
 161   2        {
 162   3          uint32_t test_sum = sum_iu;
 163   3          TX1_write2buff('i');
 164   3          TX1_write2buff('=');
 165   3          while(test_sum){
 166   4            TX1_write2buff('0'+(test_sum%10));//test
 167   4            test_sum /= 10;
 168   4          }
 169   3        }
 170   2      #endif
 171   2          
 172   2          if(sum_iu > IU_MAX){      // >100%
 173   3            pwrled_time = PWR_LED_MAX;
 174   3            lowprio_off();
 175   3      //      TX1_write2buff('M');//test
 176   3          }
 177   2          else if(sum_iu > IU_MID){ // >95%
 178   3            pwrled_time = PWR_LED_FAST;
C51 COMPILER V9.57.0.0   POE_M                                                             06/23/2018 13:54:08 PAGE 4   

 179   3      //      TX1_write2buff('m');//test
 180   3          }
 181   2          else if(sum_iu > IU_NOR){ // >75%
 182   3            pwrled_time = PWR_LED_SLOW;
 183   3            ttall_write(DET_EN, 0xFF);
 184   3      //      highprio_on();
 185   3            ttall_write(PWR_ON, 0x0F);
 186   3      //      TX1_write2buff('S');//test
 187   3          }
 188   2          else{                     // <=75%
 189   3            pwrled_time = PWR_LED_STOP;
 190   3            PWR_LED = PWR_LED_OFF;
 191   3            ttall_write(DET_EN, 0xFF);
 192   3      //      highprio_on();
 193   3            ttall_write(PWR_ON, 0x0F);
 194   3      //      TX1_write2buff('s');//test
 195   3          }
 196   2      //    TX1_write2buff('\n');//test
 197   2        }
 198   1      }
 199          
 200          //========================================================================
 201          // function:    lowprio_off
 202          // description: close gate witch is ON and lower previlige
 203          // parameter:   void
 204          // return:      closed flag
 205          // version:     V1.0, 2018-6-18
 206          //========================================================================
 207          static void lowprio_off(void){
 208   1        char xdata ret = 0, dev = 0, ch = 0;
 209   1        uint8_t pwr_state = 0, g_state = 0;
 210   1        for(dev=MAX_DEVICE-1; dev>=0; dev--){
 211   2          ret = tt_read(dev, PWR_STATE, &pwr_state);  //read pwr state
 212   2          if(ret) continue;
 213   2          for(ch=MAX_CH-1; ch>=0; ch--){
 214   3            if((pwr_state>>ch)&0x01 == G_ON){   //get pwr_on channal
 215   4              g_state |= (0x10<<ch);
 216   4              tt_write(dev, PWR_ON, g_state); //set pwr on/off
 217   4              return;
 218   4            }
 219   3          }
 220   2        }
 221   1      }
 222          
 223          //========================================================================
 224          // function:    highprio_on
 225          // description: open gate witch is OFF and higher previlige
 226          // parameter:   void
 227          // return:      closed flag
 228          // version:     V1.0, 2018-6-18
 229          //========================================================================
 230          static void highprio_on(void){
 231   1        uint8_t xdata ret = 0, dev = 0, ch = 0;
 232   1        uint8_t pwr_state = 0, g_state = 0;
 233   1        for(dev=0; dev<MAX_DEVICE; dev++){
 234   2          ret = tt_read(dev, PWR_STATE, &pwr_state);  //read pwr state
 235   2          if(ret)
 236   2            continue;
 237   2          for(ch=0; ch<MAX_CH; ch++){
 238   3            if(((pwr_state>>ch)&0x01) == G_OFF){
 239   4              g_state |= (0x01<<ch);
 240   4              tt_write(dev, PWR_ON, g_state); //set pwr on/off
C51 COMPILER V9.57.0.0   POE_M                                                             06/23/2018 13:54:08 PAGE 5   

 241   4              return;
 242   4            }
 243   3          }
 244   2        }
 245   1      }
 246          
 247          //========================================================================
 248          // function:    set_led
 249          // description: set led on/off
 250          // parameter:   device, channel, state
 251          // return:      void
 252          // version:     V2.0, 2018-6-18
 253          //========================================================================
 254          static void set_led(uint8_t dev, uint8_t ch, bit val){
 255   1        uint8_t l = 0xff;
 256   1        if(dev<6 && ch<MAX_CH)
 257   1          l = dev*MAX_CH+ch;
 258   1        l += 8;
 259   1        switch(l){
 260   2          case 0:  L1 = val; break;
 261   2          case 1:  L2 = val; break;
 262   2          case 2:  L3 = val; break;
 263   2          case 3:  L4 = val; break;
 264   2          case 4:  L5 = val; break;
 265   2          case 5:  L6 = val; break;
 266   2          case 6:  L7 = val; break;
 267   2          case 7:  L8 = val; break;
 268   2          case 8:  L9 = val; break;
 269   2          case 9:  L10 = val; break;
 270   2          case 10: L11 = val; break;
 271   2          case 11: L12 = val; break;
 272   2          case 12: L13 = val; break;
 273   2          case 13: L14 = val; break;
 274   2          case 14: L15 = val; break;
 275   2          case 15: L16 = val; break;
 276   2          case 16: L17 = val; break;
 277   2          case 17: L18 = val; break;
 278   2          case 18: L19 = val; break;
 279   2          case 19: L20 = val; break;
 280   2          case 20: L21 = val; break;
 281   2          case 21: L22 = val; break;
 282   2          case 22: L23 = val; break;
 283   2          case 23: L24 = val; break;
 284   2          default:break;
 285   2        }
 286   1      }
 287          
 288          //========================================================================
 289          // function:    set_lalled
 290          // description: set led on/off
 291          // parameter:   state
 292          // return:      void
 293          // version:     V2.0, 2018-6-18
 294          //========================================================================
 295          static void set_allled(bit val){
 296   1        uint8_t dev, ch;
 297   1        for(dev=0; dev<MAX_DEVICE; dev++)
 298   1          for(ch=0; ch<MAX_CH; ch++)
 299   1            set_led(dev, ch, val);          //set led all 
 300   1      }
 301          

C51 COMPILER V9.57.0.0   POE_M                                                             06/23/2018 13:54:08 PAGE 6   


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1166    ----
   CONSTANT SIZE    =     23    ----
   XDATA SIZE       =      8       8
   PDATA SIZE       =   ----    ----
   DATA SIZE        =      5      26
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----       2
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
